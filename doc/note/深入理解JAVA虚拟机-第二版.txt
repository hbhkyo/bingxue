第一部分：走进java
第一章 走进java
JRE： java-se-api子集和java虚拟机。
JDK： java程序设计，java-api类库，java虚拟机。

第二部分：自动内存管理机制
第二章 java内存区域与内存溢出异常
内存区域：
1.程序计数器，当前线程执行字节码的行号指示器。唯一一个没有OutOfMemoryError情况的区域。
2.java虚拟机栈，当前线程存储局部变量表的内存空间。编译期间完成确定的内存分配。不会随运行改变。规定了两种异常：
当线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError。
如果虚拟机栈可以动态扩展，当扩展无法申请到足够的内存，抛出OutOfMemoryError。
3.本地方法栈，与java虚拟机栈类似。有些虚拟机会把java虚拟机和本地方法栈合二为一。
4.java堆，所有线程共享的内存区，对象分配存放区。可固定和扩展的设置大小。 -Xmx -Xms设置。
当无法扩展时，抛出OutOfMemoryError
5.方法区，所有线程共享，存放类加载信息，常量，静态变量等。也叫非堆以示区分。当方法区无法满足内存分配时抛出OutOfMemoryError
内存溢出实战：
访问对象的方式有句柄和指针。指针更快一步。句柄在对象变动时不用改变reference。
--堆内存溢出(-Xms 20m -Xmx 20m 最小最大相同时不会扩展。 -XX +HeapDumpOnOutOfMemoryError 打印快照)：
java.lang.OutOfMemoryError: Java heap space 检查GC Roots引用链，看是否是没有回收，或者对象还有使用。
--虚拟机栈和本地方法栈溢出(-Xss 128k)：
单线程只会出现java.lang.StackOverflowError. 
多线程会出现java.lang.OutOfMemoryError 。进程内存-最大堆-最大方法区=虚拟机栈和本地方法栈。
每个线程分配到的内存越大，建立的线程就越少。可以通过减少最大堆和减少栈容量来换取创建更多的线程。
--方法区和运行时常量池溢出
jdk1.6常量池分配在永久代中，可以通过 -XX:PermSize=10M -XX:MaxPermSize=10M 限制方法区大小。
java.lang.OutOfMemoryError PermGen space
--本机直接内存溢出(-XX：)：MaxDirectMemorySize=10m
Heap Dump中不会有明显异常，Dump文件很小，又使用了NIO。则可能是本机直接内存溢出。

第三章 垃圾收集器和内存分配策略
1.对象引用：
java是采用的可达性分析算法(GC Roots链)判断对象是否存活需要垃圾回收，并不是引用计数法。
GC Roots ：虚拟机栈中引用的对象，方法区中静态属性引用的对象，方法区中常量引用的对象，本地方法(native)引用的对象。
引用并非单纯的reference类型存储的地址是另外一块内存的起始地址。JDK1.2后分为强引用，软引用，弱引用，虚引用四种。
生存和死亡规则，GC Roots链没有引用时，当前没有覆盖finalize方法或已经被虚拟机调用过一次。就会回收。finalize方法只会被调用一次，
对象有一次逃脱机会。但是不建议使用finalize方法。
方法区回收，有些没有垃圾回收，效率不高，一般新生代区一次回收能回收70-95%的空间。而永久代回收效果差。且回收条件判断比较麻烦。
2.垃圾回收算法：
--标记清除法：效率不高，回收后内存存在碎片。
--复制算法：分成均等的两块内存，存活的复制到一块上。另一块全部清除，效率高，内存不存在碎片。但是只有一半的内存能使用。代价太大了。
但是改进后可以分成三块内存空间，80%(Eden区) 10%(survivor)10%。用一小块存储存活对象。但是存在风险。需要额外的空间进行担保。适合新生代对象。
--标记整理算法：类似标记清除，区别是让存活对象都向一端移动，保证内存连续性。适合老年代对象。
--分代收集算法：结合复制算法和标记整理算法。把堆分成几块分别实现垃圾收集算法。
3.垃圾回收器实现：
--Serial收集器：单线程收集，高效，但是会停顿。Client模式下可以选择。
--ParNew收集器：能配合CMS收集器收集新生代对象。多核优势。
--CMS(concurrent mark sweep)收集器：最短停顿时间为目标的收集器。适合B/S互联网。
初始标记，并发标记，重新标记，并发清除。对CPU要求比较高，无法处理浮动垃圾，清除后没有整理内存会存在碎片。通过参数设置整理内存碎片。
--G1收集器：替代CMS收集器，高效的并行和并发，分代收集，空间整合，由清除变成清理，可预测的停顿。
4.GC日志：
33.125：  GC           DefNew  3324k-152k(3712k) 0.0025925secs     3324k-152k(11904k) 0.0031680 secs
发生时间   GC停顿类型    GC区域   GC前该内存区域已使用大小到回收后已使用大小(该区域总大小) GC时间
							  GC前java堆已使用大小到回收后已使用大小(java堆总大小)
垃圾收集器参数配置查手册
5.内存分配与回收：
新时代进入Eden区(大块区) 当没有空间时发生一次GC
大对象直接进入老年代 长期存活的对象进入老年代 
没有固定的收集器和参数组合，也没有最优的调优方法。也没有必然的回收方法。
根据需求，选择虚拟机提供的不同收集器，大量的调节参数。获得最高性能。

第四章 虚拟机性能监控与故障处理
1.JDK命令攻击：
jps:虚拟机进程状况工具 jps -lv 显示本地虚拟机唯一ID(LVMID)。对本地虚拟机来说LVMID与操作系统进程(PID)一致。也可用PS查询出来。
但是当有多个虚拟机进程，无法根据进程名称d定位，只能通过jps显示主类的功能区分。
jstat:虚拟机统计信息监视工具 jstat -gcutil 4604
jinfo:java配置信息工具 jinfo -flag  NewSize  4604
jmap:java内存映像工具 jmap -head 4604 //  jmap -dump:format=b,file=eclipse.bin 4604
jhat:虚拟机堆转储快照分析工具(不实用，每可视化分析工具好用)
jstack:java堆栈跟踪工具 jstack -l 4604
2.可视化分析工具 VisualVM JConsole Eclipse插件Memory Analyzer Tool(MAT)
3.HSDIS：JIT生成代码反汇编。生成汇编代码。

第五章 调优案列分析与实战
案列1：64位虚拟机变更成32位虚拟机集群。
高性能硬件部署，通过64位虚拟机来使用大内存 通过若干个32位虚拟机建立集群逻辑来利用硬件资源。
控制Full GC频率关键的因素是看大多数对象是否朝生夕灭。大对象不能长时间生存，批量生产。这样老年代空间才稳定。
64位虚拟机面临如下问题：
内存回收导致的长时间停顿
64位虚拟机性能测试不如32位虚拟机
要保证程序稳定，不能堆溢出，不然10几G的dump文件无法分析
64位虚拟机内存消耗比32位大。由于指针膨胀和数据类型对齐补充引起的。
所以一般是一台物理机，启用多个应用服务进程，为每个进程分配端口。再在前端搭建一个负载均衡。
案列2：内存溢出时分析headdump文件，查看那些大对象长时间占用内存
案列3：本机直接内存溢出(没有生产headdump文件) 可以通过 -XX：MaxDirectMemorySize动态调整大小，内存不足时抛出OutOfMemoryError
线程堆栈可以通过-Xss调整。纵向无法分配栈帧抛出StackOverflowError 横向无法分配建立新的线程抛出OutOfMemoryError
案列4：Eclipse运行速度调优

第三部分： 虚拟机执行子系统 
第六章 类文件结构

第七章 虚拟机类加载机制
启动类加载器 bootstrap classload --  extension classload  --  application classload  --  user classload 
双亲委托类加载模式，都会先上传递加载。

第八章 虚拟机字节码执行引擎
第九章 类加载及执行子系统的案列与实战
java逆向移植 JDK1.5写的代码放到1.4，1.3上面部署。
实战：在服务器端实现执行临时代码的功能 比如上传JSP到服务端，在页面执行访问JSP

第四部分 程序编译与代码优化
第十章 早期(预编译)优化
1.前端编译器  java-class
泛型与类型擦除。通过class反编译可以发现是伪泛型。自动装箱拆箱与foreach循环
实战：插入式注解处理器
2.后端运行编译器  class-机器码
3.静态提前编译器  java-机器码

第十一章 晚期(运行期)优化

第五部分 高效并发
第十二章 java内存模型与线程
JSR133 主内存和工作内存
变量存储在主内存，工作内存是一份拷贝，如何同步到主内存。java内存模型定义了8种操作来完成。每一种操作都是原子的。
lock 锁定 主内存，把一个变量标识为一个线程独占状态。
unloc 解锁 主内存，把一个锁定变量释放出来
read 读取 主内存，把变量读到工作内存中
load 载入 工作内存，把read的变量拷贝到工作内存中
use 使用 工作内存，把工作内存的变量传递给执行引擎，供虚拟机使用
assign 赋值 工作内存，赋值给这个工作内存的变量
store 存储 工作内存，把工作内存的变量传送到主内存
write 写入 主内存，把store操作的工作内存变量写入主内存变量

volatile变量：
只保证对所有线程的可见性 
1.运算结果不依赖变量的当前值，或者能保证只有一个线程修改变量的值
2.变量不需要与其他状态变量共同参与不变约束
禁止指令重排序优化
DCL双重检索单例模式。JDK1.5修复了volatile。

原子性 可见性 有序性
atomicity
visibility
ordering

java与线程
线程是比进程更轻量级的调度执行单位，可以把进程的资源与调度分开，各个线程可以共享进程资源(内存，IO)，又可以独立调度(CPU)

第十三章 线程安全与锁优化
加同步  比较交换CAS ABA问题  


CPU最高
top -Hp pid

16进制转换
printf "%x\n" tid

堆栈
./jstack pid |grep tid


数量大小
./jmap -histo 18372|grep fuiou |sort -k 2 -g -r|less

内存大小
./jmap -histo 18372|head -10








